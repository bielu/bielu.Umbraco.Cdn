//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.2.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import moment from 'moment';

export interface IManagementClient {

    getAuditHistory(): Promise<(AuditRecord | null)[]>;

    getAllRecords(id?: number | undefined): Promise<(AuditRecord | null)[]>;

    getLastLog(id?: number | undefined): Promise<AuditRecord>;

    getProviders(id?: number | undefined): Promise<Provider[]>;

    refreshDomain(providerId?: string | undefined, domain?: string | undefined): Promise<Status>;

    refreshForNode(id?: number | undefined, descandants?: boolean | undefined, references?: boolean | undefined, providerId?: string | undefined, domain?: string | undefined): Promise<Status>;

    refreshForProvider(providerId?: string | undefined): Promise<Status>;

    refreshAll(): Promise<Status>;
}

export class ManagementClient implements IManagementClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    getAuditHistory(): Promise<(AuditRecord | null)[]> {
        let url_ = this.baseUrl + "/cdn/api/management/GetAuditHistory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuditHistory(_response);
        });
    }

    protected processGetAuditHistory(response: Response): Promise<(AuditRecord | null)[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditRecord.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(AuditRecord | null)[]>(null as any);
    }

    getAllRecords(id?: number | undefined): Promise<(AuditRecord | null)[]> {
        let url_ = this.baseUrl + "/cdn/api/management/GetAllRecords?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRecords(_response);
        });
    }

    protected processGetAllRecords(response: Response): Promise<(AuditRecord | null)[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditRecord.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<(AuditRecord | null)[]>(null as any);
    }

    getLastLog(id?: number | undefined): Promise<AuditRecord> {
        let url_ = this.baseUrl + "/cdn/api/management/GetLastLog?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastLog(_response);
        });
    }

    protected processGetLastLog(response: Response): Promise<AuditRecord> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AuditRecord.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuditRecord>(null as any);
    }

    getProviders(id?: number | undefined): Promise<Provider[]> {
        let url_ = this.baseUrl + "/cdn/api/management/GetProviders?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProviders(_response);
        });
    }

    protected processGetProviders(response: Response): Promise<Provider[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Provider.fromJS(item, _mappings));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Provider[]>(null as any);
    }

    refreshDomain(providerId?: string | undefined, domain?: string | undefined): Promise<Status> {
        let url_ = this.baseUrl + "/cdn/api/management/RefreshDomain?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshDomain(_response);
        });
    }

    protected processRefreshDomain(response: Response): Promise<Status> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Status.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Status>(null as any);
    }

    refreshForNode(id?: number | undefined, descandants?: boolean | undefined, references?: boolean | undefined, providerId?: string | undefined, domain?: string | undefined): Promise<Status> {
        let url_ = this.baseUrl + "/cdn/api/management/RefreshForNode?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (descandants === null)
            throw new Error("The parameter 'descandants' cannot be null.");
        else if (descandants !== undefined)
            url_ += "descandants=" + encodeURIComponent("" + descandants) + "&";
        if (references === null)
            throw new Error("The parameter 'references' cannot be null.");
        else if (references !== undefined)
            url_ += "references=" + encodeURIComponent("" + references) + "&";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        if (domain === null)
            throw new Error("The parameter 'domain' cannot be null.");
        else if (domain !== undefined)
            url_ += "domain=" + encodeURIComponent("" + domain) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshForNode(_response);
        });
    }

    protected processRefreshForNode(response: Response): Promise<Status> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Status.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Status>(null as any);
    }

    refreshForProvider(providerId?: string | undefined): Promise<Status> {
        let url_ = this.baseUrl + "/cdn/api/management/RefreshForProvider?";
        if (providerId === null)
            throw new Error("The parameter 'providerId' cannot be null.");
        else if (providerId !== undefined)
            url_ += "providerId=" + encodeURIComponent("" + providerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshForProvider(_response);
        });
    }

    protected processRefreshForProvider(response: Response): Promise<Status> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Status.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Status>(null as any);
    }

    refreshAll(): Promise<Status> {
        let url_ = this.baseUrl + "/cdn/api/management/RefreshAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefreshAll(_response);
        });
    }

    protected processRefreshAll(response: Response): Promise<Status> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Status.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Status>(null as any);
    }
}

export class AuditRecord implements IAuditRecord {
    isFromProvider!: boolean;
    name!: string | null;
    date!: moment.Moment;
    message!: string | null;
    details!: string | null;
    username!: string | null;

    constructor(data?: IAuditRecord) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.isFromProvider = _data["isFromProvider"] !== undefined ? _data["isFromProvider"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.date = _data["date"] ? moment.parseZone(_data["date"].toString()) : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): AuditRecord | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AuditRecord>(data, _mappings, AuditRecord);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFromProvider"] = this.isFromProvider !== undefined ? this.isFromProvider : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["date"] = this.date ? this.date.toISOString(true) : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        return data;
    }
}

export interface IAuditRecord {
    isFromProvider: boolean;
    name: string | null;
    date: moment.Moment;
    message: string | null;
    details: string | null;
    username: string | null;
}

export class Provider implements IProvider {
    enabled!: boolean;
    id!: string | null;
    name!: string | null;
    supportedHostnames!: string[] | null;
    version!: string;

    constructor(data?: IProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.enabled = _data["enabled"] !== undefined ? _data["enabled"] : <any>null;
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["supportedHostnames"])) {
                this.supportedHostnames = [] as any;
                for (let item of _data["supportedHostnames"])
                    this.supportedHostnames!.push(item);
            }
            else {
                this.supportedHostnames = <any>null;
            }
            this.version = _data["version"] !== undefined ? _data["version"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Provider | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Provider>(data, _mappings, Provider);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled !== undefined ? this.enabled : <any>null;
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.supportedHostnames)) {
            data["supportedHostnames"] = [];
            for (let item of this.supportedHostnames)
                data["supportedHostnames"].push(item);
        }
        data["version"] = this.version !== undefined ? this.version : <any>null;
        return data;
    }
}

export interface IProvider {
    enabled: boolean;
    id: string | null;
    name: string | null;
    supportedHostnames: string[] | null;
    version: string;
}

export class Status implements IStatus {
    success!: boolean;
    message!: string | null;
    details!: string | null;
    errors!: (Errors | null)[] | null;
    exception!: Exception | null;
    messageType!: EventMessageType | null;

    constructor(data?: IStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.success = _data["success"] !== undefined ? _data["success"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.details = _data["details"] !== undefined ? _data["details"] : <any>null;
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(Errors.fromJS(item, _mappings));
            }
            else {
                this.errors = <any>null;
            }
            this.exception = _data["exception"] ? Exception.fromJS(_data["exception"], _mappings) : <any>null;
            this.messageType = _data["messageType"] !== undefined ? _data["messageType"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Status | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Status>(data, _mappings, Status);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success !== undefined ? this.success : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["details"] = this.details !== undefined ? this.details : <any>null;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        data["exception"] = this.exception ? this.exception.toJSON() : <any>null;
        data["messageType"] = this.messageType !== undefined ? this.messageType : <any>null;
        return data;
    }
}

export interface IStatus {
    success: boolean;
    message: string | null;
    details: string | null;
    errors: (Errors | null)[] | null;
    exception: Exception | null;
    messageType: EventMessageType | null;
}

export class Errors implements IErrors {
    code!: number;
    message!: string | null;

    constructor(data?: IErrors) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.code = _data["code"] !== undefined ? _data["code"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Errors | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Errors>(data, _mappings, Errors);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code !== undefined ? this.code : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IErrors {
    code: number;
    message: string | null;
}

export class Exception implements IException {
    targetSite!: MethodBase | null;
    hasBeenThrown!: boolean;
    serializationWatsonBuckets!: any | null;
    message!: string;
    data!: any[];
    innerException!: Exception | null;
    helpLink!: string | null;
    source!: string | null;
    hResult!: number;
    stackTrace!: string | null;
    serializationStackTraceString!: string | null;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.targetSite = _data["targetSite"] ? MethodBase.fromJS(_data["targetSite"], _mappings) : <any>null;
            this.hasBeenThrown = _data["hasBeenThrown"] !== undefined ? _data["hasBeenThrown"] : <any>null;
            this.serializationWatsonBuckets = _data["serializationWatsonBuckets"] !== undefined ? _data["serializationWatsonBuckets"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            else {
                this.data = <any>null;
            }
            this.innerException = _data["innerException"] ? Exception.fromJS(_data["innerException"], _mappings) : <any>null;
            this.helpLink = _data["helpLink"] !== undefined ? _data["helpLink"] : <any>null;
            this.source = _data["source"] !== undefined ? _data["source"] : <any>null;
            this.hResult = _data["hResult"] !== undefined ? _data["hResult"] : <any>null;
            this.stackTrace = _data["stackTrace"] !== undefined ? _data["stackTrace"] : <any>null;
            this.serializationStackTraceString = _data["serializationStackTraceString"] !== undefined ? _data["serializationStackTraceString"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Exception | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Exception>(data, _mappings, Exception);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetSite"] = this.targetSite ? this.targetSite.toJSON() : <any>null;
        data["hasBeenThrown"] = this.hasBeenThrown !== undefined ? this.hasBeenThrown : <any>null;
        data["serializationWatsonBuckets"] = this.serializationWatsonBuckets !== undefined ? this.serializationWatsonBuckets : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["innerException"] = this.innerException ? this.innerException.toJSON() : <any>null;
        data["helpLink"] = this.helpLink !== undefined ? this.helpLink : <any>null;
        data["source"] = this.source !== undefined ? this.source : <any>null;
        data["hResult"] = this.hResult !== undefined ? this.hResult : <any>null;
        data["stackTrace"] = this.stackTrace !== undefined ? this.stackTrace : <any>null;
        data["serializationStackTraceString"] = this.serializationStackTraceString !== undefined ? this.serializationStackTraceString : <any>null;
        return data;
    }
}

export interface IException {
    targetSite: MethodBase | null;
    hasBeenThrown: boolean;
    serializationWatsonBuckets: any | null;
    message: string;
    data: any[];
    innerException: Exception | null;
    helpLink: string | null;
    source: string | null;
    hResult: number;
    stackTrace: string | null;
    serializationStackTraceString: string | null;
}

export abstract class MemberInfo implements IMemberInfo {
    memberType!: MemberTypes;
    name!: string;
    declaringType!: string | null;
    reflectedType!: string | null;
    module!: Module;
    customAttributes!: CustomAttributeData[];
    isCollectible!: boolean;
    metadataToken!: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.memberType = _data["memberType"] !== undefined ? _data["memberType"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.declaringType = _data["declaringType"] !== undefined ? _data["declaringType"] : <any>null;
            this.reflectedType = _data["reflectedType"] !== undefined ? _data["reflectedType"] : <any>null;
            this.module = _data["module"] ? Module.fromJS(_data["module"], _mappings) : <any>null;
            if (Array.isArray(_data["customAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item, _mappings));
            }
            else {
                this.customAttributes = <any>null;
            }
            this.isCollectible = _data["isCollectible"] !== undefined ? _data["isCollectible"] : <any>null;
            this.metadataToken = _data["metadataToken"] !== undefined ? _data["metadataToken"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MemberInfo | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MemberInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType !== undefined ? this.memberType : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["declaringType"] = this.declaringType !== undefined ? this.declaringType : <any>null;
        data["reflectedType"] = this.reflectedType !== undefined ? this.reflectedType : <any>null;
        data["module"] = this.module ? this.module.toJSON() : <any>null;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["isCollectible"] = this.isCollectible !== undefined ? this.isCollectible : <any>null;
        data["metadataToken"] = this.metadataToken !== undefined ? this.metadataToken : <any>null;
        return data;
    }
}

export interface IMemberInfo {
    memberType: MemberTypes;
    name: string;
    declaringType: string | null;
    reflectedType: string | null;
    module: Module;
    customAttributes: CustomAttributeData[];
    isCollectible: boolean;
    metadataToken: number;
}

export abstract class MethodBase extends MemberInfo implements IMethodBase {
    attributes!: MethodAttributes;
    methodImplementationFlags!: MethodImplAttributes;
    callingConvention!: CallingConventions;
    isAbstract!: boolean;
    isConstructor!: boolean;
    isFinal!: boolean;
    isHideBySig!: boolean;
    isSpecialName!: boolean;
    isStatic!: boolean;
    isVirtual!: boolean;
    isAssembly!: boolean;
    isFamily!: boolean;
    isFamilyAndAssembly!: boolean;
    isFamilyOrAssembly!: boolean;
    isPrivate!: boolean;
    isPublic!: boolean;
    isConstructedGenericMethod!: boolean;
    isGenericMethod!: boolean;
    isGenericMethodDefinition!: boolean;
    containsGenericParameters!: boolean;
    methodHandle!: RuntimeMethodHandle;
    isSecurityCritical!: boolean;
    isSecuritySafeCritical!: boolean;
    isSecurityTransparent!: boolean;

    constructor(data?: IMethodBase) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.attributes = _data["attributes"] !== undefined ? _data["attributes"] : <any>null;
            this.methodImplementationFlags = _data["methodImplementationFlags"] !== undefined ? _data["methodImplementationFlags"] : <any>null;
            this.callingConvention = _data["callingConvention"] !== undefined ? _data["callingConvention"] : <any>null;
            this.isAbstract = _data["isAbstract"] !== undefined ? _data["isAbstract"] : <any>null;
            this.isConstructor = _data["isConstructor"] !== undefined ? _data["isConstructor"] : <any>null;
            this.isFinal = _data["isFinal"] !== undefined ? _data["isFinal"] : <any>null;
            this.isHideBySig = _data["isHideBySig"] !== undefined ? _data["isHideBySig"] : <any>null;
            this.isSpecialName = _data["isSpecialName"] !== undefined ? _data["isSpecialName"] : <any>null;
            this.isStatic = _data["isStatic"] !== undefined ? _data["isStatic"] : <any>null;
            this.isVirtual = _data["isVirtual"] !== undefined ? _data["isVirtual"] : <any>null;
            this.isAssembly = _data["isAssembly"] !== undefined ? _data["isAssembly"] : <any>null;
            this.isFamily = _data["isFamily"] !== undefined ? _data["isFamily"] : <any>null;
            this.isFamilyAndAssembly = _data["isFamilyAndAssembly"] !== undefined ? _data["isFamilyAndAssembly"] : <any>null;
            this.isFamilyOrAssembly = _data["isFamilyOrAssembly"] !== undefined ? _data["isFamilyOrAssembly"] : <any>null;
            this.isPrivate = _data["isPrivate"] !== undefined ? _data["isPrivate"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.isConstructedGenericMethod = _data["isConstructedGenericMethod"] !== undefined ? _data["isConstructedGenericMethod"] : <any>null;
            this.isGenericMethod = _data["isGenericMethod"] !== undefined ? _data["isGenericMethod"] : <any>null;
            this.isGenericMethodDefinition = _data["isGenericMethodDefinition"] !== undefined ? _data["isGenericMethodDefinition"] : <any>null;
            this.containsGenericParameters = _data["containsGenericParameters"] !== undefined ? _data["containsGenericParameters"] : <any>null;
            this.methodHandle = _data["methodHandle"] ? RuntimeMethodHandle.fromJS(_data["methodHandle"], _mappings) : <any>null;
            this.isSecurityCritical = _data["isSecurityCritical"] !== undefined ? _data["isSecurityCritical"] : <any>null;
            this.isSecuritySafeCritical = _data["isSecuritySafeCritical"] !== undefined ? _data["isSecuritySafeCritical"] : <any>null;
            this.isSecurityTransparent = _data["isSecurityTransparent"] !== undefined ? _data["isSecurityTransparent"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MethodBase | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MethodBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes !== undefined ? this.attributes : <any>null;
        data["methodImplementationFlags"] = this.methodImplementationFlags !== undefined ? this.methodImplementationFlags : <any>null;
        data["callingConvention"] = this.callingConvention !== undefined ? this.callingConvention : <any>null;
        data["isAbstract"] = this.isAbstract !== undefined ? this.isAbstract : <any>null;
        data["isConstructor"] = this.isConstructor !== undefined ? this.isConstructor : <any>null;
        data["isFinal"] = this.isFinal !== undefined ? this.isFinal : <any>null;
        data["isHideBySig"] = this.isHideBySig !== undefined ? this.isHideBySig : <any>null;
        data["isSpecialName"] = this.isSpecialName !== undefined ? this.isSpecialName : <any>null;
        data["isStatic"] = this.isStatic !== undefined ? this.isStatic : <any>null;
        data["isVirtual"] = this.isVirtual !== undefined ? this.isVirtual : <any>null;
        data["isAssembly"] = this.isAssembly !== undefined ? this.isAssembly : <any>null;
        data["isFamily"] = this.isFamily !== undefined ? this.isFamily : <any>null;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly !== undefined ? this.isFamilyAndAssembly : <any>null;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly !== undefined ? this.isFamilyOrAssembly : <any>null;
        data["isPrivate"] = this.isPrivate !== undefined ? this.isPrivate : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["isConstructedGenericMethod"] = this.isConstructedGenericMethod !== undefined ? this.isConstructedGenericMethod : <any>null;
        data["isGenericMethod"] = this.isGenericMethod !== undefined ? this.isGenericMethod : <any>null;
        data["isGenericMethodDefinition"] = this.isGenericMethodDefinition !== undefined ? this.isGenericMethodDefinition : <any>null;
        data["containsGenericParameters"] = this.containsGenericParameters !== undefined ? this.containsGenericParameters : <any>null;
        data["methodHandle"] = this.methodHandle ? this.methodHandle.toJSON() : <any>null;
        data["isSecurityCritical"] = this.isSecurityCritical !== undefined ? this.isSecurityCritical : <any>null;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical !== undefined ? this.isSecuritySafeCritical : <any>null;
        data["isSecurityTransparent"] = this.isSecurityTransparent !== undefined ? this.isSecurityTransparent : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IMethodBase extends IMemberInfo {
    attributes: MethodAttributes;
    methodImplementationFlags: MethodImplAttributes;
    callingConvention: CallingConventions;
    isAbstract: boolean;
    isConstructor: boolean;
    isFinal: boolean;
    isHideBySig: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isVirtual: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isConstructedGenericMethod: boolean;
    isGenericMethod: boolean;
    isGenericMethodDefinition: boolean;
    containsGenericParameters: boolean;
    methodHandle: RuntimeMethodHandle;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
}

export enum MethodAttributes {
    ReuseSlot = 0,
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    MemberAccessMask = 7,
    UnmanagedExport = 8,
    Static = 16,
    Final = 32,
    Virtual = 64,
    HideBySig = 128,
    NewSlot = 256,
    VtableLayoutMask = 256,
    CheckAccessOnOverride = 512,
    Abstract = 1024,
    SpecialName = 2048,
    RTSpecialName = 4096,
    PinvokeImpl = 8192,
    HasSecurity = 16384,
    RequireSecObject = 32768,
    ReservedMask = 53248,
}

export enum MethodImplAttributes {
    IL = 0,
    Managed = 0,
    Native = 1,
    OPTIL = 2,
    Runtime = 3,
    CodeTypeMask = 3,
    Unmanaged = 4,
    ManagedMask = 4,
    NoInlining = 8,
    ForwardRef = 16,
    Synchronized = 32,
    NoOptimization = 64,
    PreserveSig = 128,
    AggressiveInlining = 256,
    AggressiveOptimization = 512,
    InternalCall = 4096,
    MaxMethodImplVal = 65535,
}

export enum CallingConventions {
    Standard = 1,
    VarArgs = 2,
    Any = 3,
    HasThis = 32,
    ExplicitThis = 64,
}

export class RuntimeMethodHandle implements IRuntimeMethodHandle {
    value!: IntPtr;

    constructor(data?: IRuntimeMethodHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RuntimeMethodHandle | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RuntimeMethodHandle>(data, _mappings, RuntimeMethodHandle);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IRuntimeMethodHandle {
    value: IntPtr;
}

export class IntPtr implements IIntPtr {
    size!: number;
    maxValue!: IntPtr;
    minValue!: IntPtr;
    systemIAdditiveIdentity<nint,nint>AdditiveIdentity!: IntPtr;
    systemIMinMaxValue<nint>MinValue!: IntPtr;
    systemIMinMaxValue<nint>MaxValue!: IntPtr;
    systemIMultiplicativeIdentity<nint,nint>MultiplicativeIdentity!: IntPtr;
    systemINumber<nint>One!: IntPtr;
    systemINumber<nint>Zero!: IntPtr;
    systemISignedNumber<nint>NegativeOne!: IntPtr;

    constructor(data?: IIntPtr) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.size = _data["size"] !== undefined ? _data["size"] : <any>null;
            this.maxValue = _data["maxValue"] ? IntPtr.fromJS(_data["maxValue"], _mappings) : <any>null;
            this.minValue = _data["minValue"] ? IntPtr.fromJS(_data["minValue"], _mappings) : <any>null;
            this.systemIAdditiveIdentity<nint,nint>AdditiveIdentity = _data["system.IAdditiveIdentity<nint,nint>.AdditiveIdentity"] ? IntPtr.fromJS(_data["system.IAdditiveIdentity<nint,nint>.AdditiveIdentity"], _mappings) : <any>null;
            this.systemIMinMaxValue<nint>MinValue = _data["system.IMinMaxValue<nint>.MinValue"] ? IntPtr.fromJS(_data["system.IMinMaxValue<nint>.MinValue"], _mappings) : <any>null;
            this.systemIMinMaxValue<nint>MaxValue = _data["system.IMinMaxValue<nint>.MaxValue"] ? IntPtr.fromJS(_data["system.IMinMaxValue<nint>.MaxValue"], _mappings) : <any>null;
            this.systemIMultiplicativeIdentity<nint,nint>MultiplicativeIdentity = _data["system.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity"] ? IntPtr.fromJS(_data["system.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity"], _mappings) : <any>null;
            this.systemINumber<nint>One = _data["system.INumber<nint>.One"] ? IntPtr.fromJS(_data["system.INumber<nint>.One"], _mappings) : <any>null;
            this.systemINumber<nint>Zero = _data["system.INumber<nint>.Zero"] ? IntPtr.fromJS(_data["system.INumber<nint>.Zero"], _mappings) : <any>null;
            this.systemISignedNumber<nint>NegativeOne = _data["system.ISignedNumber<nint>.NegativeOne"] ? IntPtr.fromJS(_data["system.ISignedNumber<nint>.NegativeOne"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): IntPtr | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<IntPtr>(data, _mappings, IntPtr);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["size"] = this.size !== undefined ? this.size : <any>null;
        data["maxValue"] = this.maxValue ? this.maxValue.toJSON() : <any>null;
        data["minValue"] = this.minValue ? this.minValue.toJSON() : <any>null;
        data["system.IAdditiveIdentity<nint,nint>.AdditiveIdentity"] = this.systemIAdditiveIdentity<nint,nint>AdditiveIdentity ? this.systemIAdditiveIdentity<nint,nint>AdditiveIdentity.toJSON() : <any>null;
        data["system.IMinMaxValue<nint>.MinValue"] = this.systemIMinMaxValue<nint>MinValue ? this.systemIMinMaxValue<nint>MinValue.toJSON() : <any>null;
        data["system.IMinMaxValue<nint>.MaxValue"] = this.systemIMinMaxValue<nint>MaxValue ? this.systemIMinMaxValue<nint>MaxValue.toJSON() : <any>null;
        data["system.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity"] = this.systemIMultiplicativeIdentity<nint,nint>MultiplicativeIdentity ? this.systemIMultiplicativeIdentity<nint,nint>MultiplicativeIdentity.toJSON() : <any>null;
        data["system.INumber<nint>.One"] = this.systemINumber<nint>One ? this.systemINumber<nint>One.toJSON() : <any>null;
        data["system.INumber<nint>.Zero"] = this.systemINumber<nint>Zero ? this.systemINumber<nint>Zero.toJSON() : <any>null;
        data["system.ISignedNumber<nint>.NegativeOne"] = this.systemISignedNumber<nint>NegativeOne ? this.systemISignedNumber<nint>NegativeOne.toJSON() : <any>null;
        return data;
    }
}

export interface IIntPtr {
    size: number;
    maxValue: IntPtr;
    minValue: IntPtr;
    systemIAdditiveIdentity<nint,nint>AdditiveIdentity: IntPtr;
    systemIMinMaxValue<nint>MinValue: IntPtr;
    systemIMinMaxValue<nint>MaxValue: IntPtr;
    systemIMultiplicativeIdentity<nint,nint>MultiplicativeIdentity: IntPtr;
    systemINumber<nint>One: IntPtr;
    systemINumber<nint>Zero: IntPtr;
    systemISignedNumber<nint>NegativeOne: IntPtr;
}

export enum MemberTypes {
    Constructor = 1,
    Event = 2,
    Field = 4,
    Method = 8,
    Property = 16,
    TypeInfo = 32,
    Custom = 64,
    NestedType = 128,
    All = 191,
}

export abstract class Module implements IModule {
    assembly!: Assembly;
    fullyQualifiedName!: string;
    name!: string;
    mdStreamVersion!: number;
    moduleVersionId!: string;
    scopeName!: string;
    moduleHandle!: ModuleHandle;
    customAttributes!: CustomAttributeData[];
    metadataToken!: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.assembly = _data["assembly"] ? Assembly.fromJS(_data["assembly"], _mappings) : <any>null;
            this.fullyQualifiedName = _data["fullyQualifiedName"] !== undefined ? _data["fullyQualifiedName"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.mdStreamVersion = _data["mdStreamVersion"] !== undefined ? _data["mdStreamVersion"] : <any>null;
            this.moduleVersionId = _data["moduleVersionId"] !== undefined ? _data["moduleVersionId"] : <any>null;
            this.scopeName = _data["scopeName"] !== undefined ? _data["scopeName"] : <any>null;
            this.moduleHandle = _data["moduleHandle"] ? ModuleHandle.fromJS(_data["moduleHandle"], _mappings) : <any>null;
            if (Array.isArray(_data["customAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item, _mappings));
            }
            else {
                this.customAttributes = <any>null;
            }
            this.metadataToken = _data["metadataToken"] !== undefined ? _data["metadataToken"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Module | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Module' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assembly"] = this.assembly ? this.assembly.toJSON() : <any>null;
        data["fullyQualifiedName"] = this.fullyQualifiedName !== undefined ? this.fullyQualifiedName : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["mdStreamVersion"] = this.mdStreamVersion !== undefined ? this.mdStreamVersion : <any>null;
        data["moduleVersionId"] = this.moduleVersionId !== undefined ? this.moduleVersionId : <any>null;
        data["scopeName"] = this.scopeName !== undefined ? this.scopeName : <any>null;
        data["moduleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>null;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken !== undefined ? this.metadataToken : <any>null;
        return data;
    }
}

export interface IModule {
    assembly: Assembly;
    fullyQualifiedName: string;
    name: string;
    mdStreamVersion: number;
    moduleVersionId: string;
    scopeName: string;
    moduleHandle: ModuleHandle;
    customAttributes: CustomAttributeData[];
    metadataToken: number;
}

export abstract class Assembly implements IAssembly {
    definedTypes!: TypeInfo[];
    exportedTypes!: string[];
    codeBase!: string | null;
    entryPoint!: MethodInfo | null;
    fullName!: string | null;
    imageRuntimeVersion!: string;
    isDynamic!: boolean;
    location!: string;
    reflectionOnly!: boolean;
    isCollectible!: boolean;
    isFullyTrusted!: boolean;
    customAttributes!: CustomAttributeData[];
    escapedCodeBase!: string;
    manifestModule!: Module;
    modules!: Module[];
    globalAssemblyCache!: boolean;
    hostContext!: number;
    securityRuleSet!: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["definedTypes"])) {
                this.definedTypes = [] as any;
                for (let item of _data["definedTypes"])
                    this.definedTypes!.push(TypeInfo.fromJS(item, _mappings));
            }
            else {
                this.definedTypes = <any>null;
            }
            if (Array.isArray(_data["exportedTypes"])) {
                this.exportedTypes = [] as any;
                for (let item of _data["exportedTypes"])
                    this.exportedTypes!.push(item);
            }
            else {
                this.exportedTypes = <any>null;
            }
            this.codeBase = _data["codeBase"] !== undefined ? _data["codeBase"] : <any>null;
            this.entryPoint = _data["entryPoint"] ? MethodInfo.fromJS(_data["entryPoint"], _mappings) : <any>null;
            this.fullName = _data["fullName"] !== undefined ? _data["fullName"] : <any>null;
            this.imageRuntimeVersion = _data["imageRuntimeVersion"] !== undefined ? _data["imageRuntimeVersion"] : <any>null;
            this.isDynamic = _data["isDynamic"] !== undefined ? _data["isDynamic"] : <any>null;
            this.location = _data["location"] !== undefined ? _data["location"] : <any>null;
            this.reflectionOnly = _data["reflectionOnly"] !== undefined ? _data["reflectionOnly"] : <any>null;
            this.isCollectible = _data["isCollectible"] !== undefined ? _data["isCollectible"] : <any>null;
            this.isFullyTrusted = _data["isFullyTrusted"] !== undefined ? _data["isFullyTrusted"] : <any>null;
            if (Array.isArray(_data["customAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item, _mappings));
            }
            else {
                this.customAttributes = <any>null;
            }
            this.escapedCodeBase = _data["escapedCodeBase"] !== undefined ? _data["escapedCodeBase"] : <any>null;
            this.manifestModule = _data["manifestModule"] ? Module.fromJS(_data["manifestModule"], _mappings) : <any>null;
            if (Array.isArray(_data["modules"])) {
                this.modules = [] as any;
                for (let item of _data["modules"])
                    this.modules!.push(Module.fromJS(item, _mappings));
            }
            else {
                this.modules = <any>null;
            }
            this.globalAssemblyCache = _data["globalAssemblyCache"] !== undefined ? _data["globalAssemblyCache"] : <any>null;
            this.hostContext = _data["hostContext"] !== undefined ? _data["hostContext"] : <any>null;
            this.securityRuleSet = _data["securityRuleSet"] !== undefined ? _data["securityRuleSet"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): Assembly | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Assembly' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.definedTypes)) {
            data["definedTypes"] = [];
            for (let item of this.definedTypes)
                data["definedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.exportedTypes)) {
            data["exportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["exportedTypes"].push(item);
        }
        data["codeBase"] = this.codeBase !== undefined ? this.codeBase : <any>null;
        data["entryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>null;
        data["fullName"] = this.fullName !== undefined ? this.fullName : <any>null;
        data["imageRuntimeVersion"] = this.imageRuntimeVersion !== undefined ? this.imageRuntimeVersion : <any>null;
        data["isDynamic"] = this.isDynamic !== undefined ? this.isDynamic : <any>null;
        data["location"] = this.location !== undefined ? this.location : <any>null;
        data["reflectionOnly"] = this.reflectionOnly !== undefined ? this.reflectionOnly : <any>null;
        data["isCollectible"] = this.isCollectible !== undefined ? this.isCollectible : <any>null;
        data["isFullyTrusted"] = this.isFullyTrusted !== undefined ? this.isFullyTrusted : <any>null;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["escapedCodeBase"] = this.escapedCodeBase !== undefined ? this.escapedCodeBase : <any>null;
        data["manifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>null;
        if (Array.isArray(this.modules)) {
            data["modules"] = [];
            for (let item of this.modules)
                data["modules"].push(item.toJSON());
        }
        data["globalAssemblyCache"] = this.globalAssemblyCache !== undefined ? this.globalAssemblyCache : <any>null;
        data["hostContext"] = this.hostContext !== undefined ? this.hostContext : <any>null;
        data["securityRuleSet"] = this.securityRuleSet !== undefined ? this.securityRuleSet : <any>null;
        return data;
    }
}

export interface IAssembly {
    definedTypes: TypeInfo[];
    exportedTypes: string[];
    codeBase: string | null;
    entryPoint: MethodInfo | null;
    fullName: string | null;
    imageRuntimeVersion: string;
    isDynamic: boolean;
    location: string;
    reflectionOnly: boolean;
    isCollectible: boolean;
    isFullyTrusted: boolean;
    customAttributes: CustomAttributeData[];
    escapedCodeBase: string;
    manifestModule: Module;
    modules: Module[];
    globalAssemblyCache: boolean;
    hostContext: number;
    securityRuleSet: SecurityRuleSet;
}

export abstract class Anonymous implements IAnonymous {
    genericTypeParameters!: string[];
    declaredConstructors!: ConstructorInfo[];
    declaredEvents!: EventInfo[];
    declaredFields!: FieldInfo[];
    declaredMembers!: MemberInfo[];
    declaredMethods!: MethodInfo[];
    declaredNestedTypes!: TypeInfo[];
    declaredProperties!: PropertyInfo[];
    implementedInterfaces!: string[];

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["genericTypeParameters"])) {
                this.genericTypeParameters = [] as any;
                for (let item of _data["genericTypeParameters"])
                    this.genericTypeParameters!.push(item);
            }
            else {
                this.genericTypeParameters = <any>null;
            }
            if (Array.isArray(_data["declaredConstructors"])) {
                this.declaredConstructors = [] as any;
                for (let item of _data["declaredConstructors"])
                    this.declaredConstructors!.push(ConstructorInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredConstructors = <any>null;
            }
            if (Array.isArray(_data["declaredEvents"])) {
                this.declaredEvents = [] as any;
                for (let item of _data["declaredEvents"])
                    this.declaredEvents!.push(EventInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredEvents = <any>null;
            }
            if (Array.isArray(_data["declaredFields"])) {
                this.declaredFields = [] as any;
                for (let item of _data["declaredFields"])
                    this.declaredFields!.push(FieldInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredFields = <any>null;
            }
            if (Array.isArray(_data["declaredMembers"])) {
                this.declaredMembers = [] as any;
                for (let item of _data["declaredMembers"])
                    this.declaredMembers!.push(MemberInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredMembers = <any>null;
            }
            if (Array.isArray(_data["declaredMethods"])) {
                this.declaredMethods = [] as any;
                for (let item of _data["declaredMethods"])
                    this.declaredMethods!.push(MethodInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredMethods = <any>null;
            }
            if (Array.isArray(_data["declaredNestedTypes"])) {
                this.declaredNestedTypes = [] as any;
                for (let item of _data["declaredNestedTypes"])
                    this.declaredNestedTypes!.push(TypeInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredNestedTypes = <any>null;
            }
            if (Array.isArray(_data["declaredProperties"])) {
                this.declaredProperties = [] as any;
                for (let item of _data["declaredProperties"])
                    this.declaredProperties!.push(PropertyInfo.fromJS(item, _mappings));
            }
            else {
                this.declaredProperties = <any>null;
            }
            if (Array.isArray(_data["implementedInterfaces"])) {
                this.implementedInterfaces = [] as any;
                for (let item of _data["implementedInterfaces"])
                    this.implementedInterfaces!.push(item);
            }
            else {
                this.implementedInterfaces = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Anonymous' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.genericTypeParameters)) {
            data["genericTypeParameters"] = [];
            for (let item of this.genericTypeParameters)
                data["genericTypeParameters"].push(item);
        }
        if (Array.isArray(this.declaredConstructors)) {
            data["declaredConstructors"] = [];
            for (let item of this.declaredConstructors)
                data["declaredConstructors"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredEvents)) {
            data["declaredEvents"] = [];
            for (let item of this.declaredEvents)
                data["declaredEvents"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredFields)) {
            data["declaredFields"] = [];
            for (let item of this.declaredFields)
                data["declaredFields"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMembers)) {
            data["declaredMembers"] = [];
            for (let item of this.declaredMembers)
                data["declaredMembers"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredMethods)) {
            data["declaredMethods"] = [];
            for (let item of this.declaredMethods)
                data["declaredMethods"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredNestedTypes)) {
            data["declaredNestedTypes"] = [];
            for (let item of this.declaredNestedTypes)
                data["declaredNestedTypes"].push(item.toJSON());
        }
        if (Array.isArray(this.declaredProperties)) {
            data["declaredProperties"] = [];
            for (let item of this.declaredProperties)
                data["declaredProperties"].push(item.toJSON());
        }
        if (Array.isArray(this.implementedInterfaces)) {
            data["implementedInterfaces"] = [];
            for (let item of this.implementedInterfaces)
                data["implementedInterfaces"].push(item);
        }
        return data;
    }
}

export interface IAnonymous {
    genericTypeParameters: string[];
    declaredConstructors: ConstructorInfo[];
    declaredEvents: EventInfo[];
    declaredFields: FieldInfo[];
    declaredMembers: MemberInfo[];
    declaredMethods: MethodInfo[];
    declaredNestedTypes: TypeInfo[];
    declaredProperties: PropertyInfo[];
    implementedInterfaces: string[];
}

export class TypeInfo extends Anonymous implements ITypeInfo {

    [key: string]: any;

    constructor(data?: ITypeInfo) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any, _mappings?: any): TypeInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TypeInfo>(data, _mappings, TypeInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITypeInfo extends IAnonymous {

    [key: string]: any;
}

export abstract class ConstructorInfo extends MethodBase implements IConstructorInfo {
    memberType!: MemberTypes;

    constructor(data?: IConstructorInfo) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["memberType"] !== undefined ? _data["memberType"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ConstructorInfo | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ConstructorInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType !== undefined ? this.memberType : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IConstructorInfo extends IMethodBase {
    memberType: MemberTypes;
}

export abstract class EventInfo extends MemberInfo implements IEventInfo {
    memberType!: MemberTypes;
    attributes!: EventAttributes;
    isSpecialName!: boolean;
    addMethod!: MethodInfo | null;
    removeMethod!: MethodInfo | null;
    raiseMethod!: MethodInfo | null;
    isMulticast!: boolean;
    eventHandlerType!: string | null;

    constructor(data?: IEventInfo) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["memberType"] !== undefined ? _data["memberType"] : <any>null;
            this.attributes = _data["attributes"] !== undefined ? _data["attributes"] : <any>null;
            this.isSpecialName = _data["isSpecialName"] !== undefined ? _data["isSpecialName"] : <any>null;
            this.addMethod = _data["addMethod"] ? MethodInfo.fromJS(_data["addMethod"], _mappings) : <any>null;
            this.removeMethod = _data["removeMethod"] ? MethodInfo.fromJS(_data["removeMethod"], _mappings) : <any>null;
            this.raiseMethod = _data["raiseMethod"] ? MethodInfo.fromJS(_data["raiseMethod"], _mappings) : <any>null;
            this.isMulticast = _data["isMulticast"] !== undefined ? _data["isMulticast"] : <any>null;
            this.eventHandlerType = _data["eventHandlerType"] !== undefined ? _data["eventHandlerType"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): EventInfo | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EventInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType !== undefined ? this.memberType : <any>null;
        data["attributes"] = this.attributes !== undefined ? this.attributes : <any>null;
        data["isSpecialName"] = this.isSpecialName !== undefined ? this.isSpecialName : <any>null;
        data["addMethod"] = this.addMethod ? this.addMethod.toJSON() : <any>null;
        data["removeMethod"] = this.removeMethod ? this.removeMethod.toJSON() : <any>null;
        data["raiseMethod"] = this.raiseMethod ? this.raiseMethod.toJSON() : <any>null;
        data["isMulticast"] = this.isMulticast !== undefined ? this.isMulticast : <any>null;
        data["eventHandlerType"] = this.eventHandlerType !== undefined ? this.eventHandlerType : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IEventInfo extends IMemberInfo {
    memberType: MemberTypes;
    attributes: EventAttributes;
    isSpecialName: boolean;
    addMethod: MethodInfo | null;
    removeMethod: MethodInfo | null;
    raiseMethod: MethodInfo | null;
    isMulticast: boolean;
    eventHandlerType: string | null;
}

export enum EventAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    ReservedMask = 1024,
}

export abstract class MethodInfo extends MethodBase implements IMethodInfo {
    memberType!: MemberTypes;
    returnParameter!: ParameterInfo;
    returnType!: string;
    returnTypeCustomAttributes!: ICustomAttributeProvider;
    genericParameterCount!: number;

    constructor(data?: IMethodInfo) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["memberType"] !== undefined ? _data["memberType"] : <any>null;
            this.returnParameter = _data["returnParameter"] ? ParameterInfo.fromJS(_data["returnParameter"], _mappings) : <any>null;
            this.returnType = _data["returnType"] !== undefined ? _data["returnType"] : <any>null;
            this.returnTypeCustomAttributes = _data["returnTypeCustomAttributes"] ? ICustomAttributeProvider.fromJS(_data["returnTypeCustomAttributes"], _mappings) : <any>null;
            this.genericParameterCount = _data["genericParameterCount"] !== undefined ? _data["genericParameterCount"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): MethodInfo | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MethodInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType !== undefined ? this.memberType : <any>null;
        data["returnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>null;
        data["returnType"] = this.returnType !== undefined ? this.returnType : <any>null;
        data["returnTypeCustomAttributes"] = this.returnTypeCustomAttributes ? this.returnTypeCustomAttributes.toJSON() : <any>null;
        data["genericParameterCount"] = this.genericParameterCount !== undefined ? this.genericParameterCount : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IMethodInfo extends IMethodBase {
    memberType: MemberTypes;
    returnParameter: ParameterInfo;
    returnType: string;
    returnTypeCustomAttributes: ICustomAttributeProvider;
    genericParameterCount: number;
}

export class ParameterInfo implements IParameterInfo {
    attributes!: ParameterAttributes;
    member!: MemberInfo;
    name!: string | null;
    parameterType!: string;
    position!: number;
    isIn!: boolean;
    isLcid!: boolean;
    isOptional!: boolean;
    isOut!: boolean;
    isRetval!: boolean;
    defaultValue!: any | null;
    rawDefaultValue!: any | null;
    hasDefaultValue!: boolean;
    customAttributes!: CustomAttributeData[];
    metadataToken!: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.attributes = _data["attributes"] !== undefined ? _data["attributes"] : <any>null;
            this.member = _data["member"] ? MemberInfo.fromJS(_data["member"], _mappings) : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.parameterType = _data["parameterType"] !== undefined ? _data["parameterType"] : <any>null;
            this.position = _data["position"] !== undefined ? _data["position"] : <any>null;
            this.isIn = _data["isIn"] !== undefined ? _data["isIn"] : <any>null;
            this.isLcid = _data["isLcid"] !== undefined ? _data["isLcid"] : <any>null;
            this.isOptional = _data["isOptional"] !== undefined ? _data["isOptional"] : <any>null;
            this.isOut = _data["isOut"] !== undefined ? _data["isOut"] : <any>null;
            this.isRetval = _data["isRetval"] !== undefined ? _data["isRetval"] : <any>null;
            this.defaultValue = _data["defaultValue"] !== undefined ? _data["defaultValue"] : <any>null;
            this.rawDefaultValue = _data["rawDefaultValue"] !== undefined ? _data["rawDefaultValue"] : <any>null;
            this.hasDefaultValue = _data["hasDefaultValue"] !== undefined ? _data["hasDefaultValue"] : <any>null;
            if (Array.isArray(_data["customAttributes"])) {
                this.customAttributes = [] as any;
                for (let item of _data["customAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item, _mappings));
            }
            else {
                this.customAttributes = <any>null;
            }
            this.metadataToken = _data["metadataToken"] !== undefined ? _data["metadataToken"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ParameterInfo | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ParameterInfo>(data, _mappings, ParameterInfo);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributes"] = this.attributes !== undefined ? this.attributes : <any>null;
        data["member"] = this.member ? this.member.toJSON() : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["parameterType"] = this.parameterType !== undefined ? this.parameterType : <any>null;
        data["position"] = this.position !== undefined ? this.position : <any>null;
        data["isIn"] = this.isIn !== undefined ? this.isIn : <any>null;
        data["isLcid"] = this.isLcid !== undefined ? this.isLcid : <any>null;
        data["isOptional"] = this.isOptional !== undefined ? this.isOptional : <any>null;
        data["isOut"] = this.isOut !== undefined ? this.isOut : <any>null;
        data["isRetval"] = this.isRetval !== undefined ? this.isRetval : <any>null;
        data["defaultValue"] = this.defaultValue !== undefined ? this.defaultValue : <any>null;
        data["rawDefaultValue"] = this.rawDefaultValue !== undefined ? this.rawDefaultValue : <any>null;
        data["hasDefaultValue"] = this.hasDefaultValue !== undefined ? this.hasDefaultValue : <any>null;
        if (Array.isArray(this.customAttributes)) {
            data["customAttributes"] = [];
            for (let item of this.customAttributes)
                data["customAttributes"].push(item.toJSON());
        }
        data["metadataToken"] = this.metadataToken !== undefined ? this.metadataToken : <any>null;
        return data;
    }
}

export interface IParameterInfo {
    attributes: ParameterAttributes;
    member: MemberInfo;
    name: string | null;
    parameterType: string;
    position: number;
    isIn: boolean;
    isLcid: boolean;
    isOptional: boolean;
    isOut: boolean;
    isRetval: boolean;
    defaultValue: any | null;
    rawDefaultValue: any | null;
    hasDefaultValue: boolean;
    customAttributes: CustomAttributeData[];
    metadataToken: number;
}

export enum ParameterAttributes {
    None = 0,
    In = 1,
    Out = 2,
    Lcid = 4,
    Retval = 8,
    Optional = 16,
    HasDefault = 4096,
    HasFieldMarshal = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 61440,
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType!: string;
    constructor_!: ConstructorInfo;
    constructorArguments!: CustomAttributeTypedArgument[];
    namedArguments!: CustomAttributeNamedArgument[];

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.attributeType = _data["attributeType"] !== undefined ? _data["attributeType"] : <any>null;
            this.constructor_ = _data["constructor"] ? ConstructorInfo.fromJS(_data["constructor"], _mappings) : <any>null;
            if (Array.isArray(_data["constructorArguments"])) {
                this.constructorArguments = [] as any;
                for (let item of _data["constructorArguments"])
                    this.constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item, _mappings));
            }
            else {
                this.constructorArguments = <any>null;
            }
            if (Array.isArray(_data["namedArguments"])) {
                this.namedArguments = [] as any;
                for (let item of _data["namedArguments"])
                    this.namedArguments!.push(CustomAttributeNamedArgument.fromJS(item, _mappings));
            }
            else {
                this.namedArguments = <any>null;
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CustomAttributeData | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomAttributeData>(data, _mappings, CustomAttributeData);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeType"] = this.attributeType !== undefined ? this.attributeType : <any>null;
        data["constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>null;
        if (Array.isArray(this.constructorArguments)) {
            data["constructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["constructorArguments"].push(item.toJSON());
        }
        if (Array.isArray(this.namedArguments)) {
            data["namedArguments"] = [];
            for (let item of this.namedArguments)
                data["namedArguments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICustomAttributeData {
    attributeType: string;
    constructor_: ConstructorInfo;
    constructorArguments: CustomAttributeTypedArgument[];
    namedArguments: CustomAttributeNamedArgument[];
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType!: string;
    value!: any | null;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] !== undefined ? _data["argumentType"] : <any>null;
            this.value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CustomAttributeTypedArgument | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomAttributeTypedArgument>(data, _mappings, CustomAttributeTypedArgument);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType !== undefined ? this.argumentType : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType: string;
    value: any | null;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    argumentType!: string;
    memberInfo!: MemberInfo;
    typedValue!: CustomAttributeTypedArgument;
    memberName!: string;
    isField!: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.argumentType = _data["argumentType"] !== undefined ? _data["argumentType"] : <any>null;
            this.memberInfo = _data["memberInfo"] ? MemberInfo.fromJS(_data["memberInfo"], _mappings) : <any>null;
            this.typedValue = _data["typedValue"] ? CustomAttributeTypedArgument.fromJS(_data["typedValue"], _mappings) : <any>null;
            this.memberName = _data["memberName"] !== undefined ? _data["memberName"] : <any>null;
            this.isField = _data["isField"] !== undefined ? _data["isField"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): CustomAttributeNamedArgument | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomAttributeNamedArgument>(data, _mappings, CustomAttributeNamedArgument);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["argumentType"] = this.argumentType !== undefined ? this.argumentType : <any>null;
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>null;
        data["typedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>null;
        data["memberName"] = this.memberName !== undefined ? this.memberName : <any>null;
        data["isField"] = this.isField !== undefined ? this.isField : <any>null;
        return data;
    }
}

export interface ICustomAttributeNamedArgument {
    argumentType: string;
    memberInfo: MemberInfo;
    typedValue: CustomAttributeTypedArgument;
    memberName: string;
    isField: boolean;
}

export abstract class ICustomAttributeProvider implements IICustomAttributeProvider {

    constructor(data?: IICustomAttributeProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
    }

    static fromJS(data: any, _mappings?: any): ICustomAttributeProvider | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ICustomAttributeProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IICustomAttributeProvider {
}

export abstract class FieldInfo extends MemberInfo implements IFieldInfo {
    memberType!: MemberTypes;
    attributes!: FieldAttributes;
    fieldType!: string;
    isInitOnly!: boolean;
    isLiteral!: boolean;
    isNotSerialized!: boolean;
    isPinvokeImpl!: boolean;
    isSpecialName!: boolean;
    isStatic!: boolean;
    isAssembly!: boolean;
    isFamily!: boolean;
    isFamilyAndAssembly!: boolean;
    isFamilyOrAssembly!: boolean;
    isPrivate!: boolean;
    isPublic!: boolean;
    isSecurityCritical!: boolean;
    isSecuritySafeCritical!: boolean;
    isSecurityTransparent!: boolean;
    fieldHandle!: RuntimeFieldHandle;

    constructor(data?: IFieldInfo) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["memberType"] !== undefined ? _data["memberType"] : <any>null;
            this.attributes = _data["attributes"] !== undefined ? _data["attributes"] : <any>null;
            this.fieldType = _data["fieldType"] !== undefined ? _data["fieldType"] : <any>null;
            this.isInitOnly = _data["isInitOnly"] !== undefined ? _data["isInitOnly"] : <any>null;
            this.isLiteral = _data["isLiteral"] !== undefined ? _data["isLiteral"] : <any>null;
            this.isNotSerialized = _data["isNotSerialized"] !== undefined ? _data["isNotSerialized"] : <any>null;
            this.isPinvokeImpl = _data["isPinvokeImpl"] !== undefined ? _data["isPinvokeImpl"] : <any>null;
            this.isSpecialName = _data["isSpecialName"] !== undefined ? _data["isSpecialName"] : <any>null;
            this.isStatic = _data["isStatic"] !== undefined ? _data["isStatic"] : <any>null;
            this.isAssembly = _data["isAssembly"] !== undefined ? _data["isAssembly"] : <any>null;
            this.isFamily = _data["isFamily"] !== undefined ? _data["isFamily"] : <any>null;
            this.isFamilyAndAssembly = _data["isFamilyAndAssembly"] !== undefined ? _data["isFamilyAndAssembly"] : <any>null;
            this.isFamilyOrAssembly = _data["isFamilyOrAssembly"] !== undefined ? _data["isFamilyOrAssembly"] : <any>null;
            this.isPrivate = _data["isPrivate"] !== undefined ? _data["isPrivate"] : <any>null;
            this.isPublic = _data["isPublic"] !== undefined ? _data["isPublic"] : <any>null;
            this.isSecurityCritical = _data["isSecurityCritical"] !== undefined ? _data["isSecurityCritical"] : <any>null;
            this.isSecuritySafeCritical = _data["isSecuritySafeCritical"] !== undefined ? _data["isSecuritySafeCritical"] : <any>null;
            this.isSecurityTransparent = _data["isSecurityTransparent"] !== undefined ? _data["isSecurityTransparent"] : <any>null;
            this.fieldHandle = _data["fieldHandle"] ? RuntimeFieldHandle.fromJS(_data["fieldHandle"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): FieldInfo | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'FieldInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType !== undefined ? this.memberType : <any>null;
        data["attributes"] = this.attributes !== undefined ? this.attributes : <any>null;
        data["fieldType"] = this.fieldType !== undefined ? this.fieldType : <any>null;
        data["isInitOnly"] = this.isInitOnly !== undefined ? this.isInitOnly : <any>null;
        data["isLiteral"] = this.isLiteral !== undefined ? this.isLiteral : <any>null;
        data["isNotSerialized"] = this.isNotSerialized !== undefined ? this.isNotSerialized : <any>null;
        data["isPinvokeImpl"] = this.isPinvokeImpl !== undefined ? this.isPinvokeImpl : <any>null;
        data["isSpecialName"] = this.isSpecialName !== undefined ? this.isSpecialName : <any>null;
        data["isStatic"] = this.isStatic !== undefined ? this.isStatic : <any>null;
        data["isAssembly"] = this.isAssembly !== undefined ? this.isAssembly : <any>null;
        data["isFamily"] = this.isFamily !== undefined ? this.isFamily : <any>null;
        data["isFamilyAndAssembly"] = this.isFamilyAndAssembly !== undefined ? this.isFamilyAndAssembly : <any>null;
        data["isFamilyOrAssembly"] = this.isFamilyOrAssembly !== undefined ? this.isFamilyOrAssembly : <any>null;
        data["isPrivate"] = this.isPrivate !== undefined ? this.isPrivate : <any>null;
        data["isPublic"] = this.isPublic !== undefined ? this.isPublic : <any>null;
        data["isSecurityCritical"] = this.isSecurityCritical !== undefined ? this.isSecurityCritical : <any>null;
        data["isSecuritySafeCritical"] = this.isSecuritySafeCritical !== undefined ? this.isSecuritySafeCritical : <any>null;
        data["isSecurityTransparent"] = this.isSecurityTransparent !== undefined ? this.isSecurityTransparent : <any>null;
        data["fieldHandle"] = this.fieldHandle ? this.fieldHandle.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IFieldInfo extends IMemberInfo {
    memberType: MemberTypes;
    attributes: FieldAttributes;
    fieldType: string;
    isInitOnly: boolean;
    isLiteral: boolean;
    isNotSerialized: boolean;
    isPinvokeImpl: boolean;
    isSpecialName: boolean;
    isStatic: boolean;
    isAssembly: boolean;
    isFamily: boolean;
    isFamilyAndAssembly: boolean;
    isFamilyOrAssembly: boolean;
    isPrivate: boolean;
    isPublic: boolean;
    isSecurityCritical: boolean;
    isSecuritySafeCritical: boolean;
    isSecurityTransparent: boolean;
    fieldHandle: RuntimeFieldHandle;
}

export enum FieldAttributes {
    PrivateScope = 0,
    Private = 1,
    FamANDAssem = 2,
    Assembly = 3,
    Family = 4,
    FamORAssem = 5,
    Public = 6,
    FieldAccessMask = 7,
    Static = 16,
    InitOnly = 32,
    Literal = 64,
    NotSerialized = 128,
    HasFieldRVA = 256,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasFieldMarshal = 4096,
    PinvokeImpl = 8192,
    HasDefault = 32768,
    ReservedMask = 38144,
}

export class RuntimeFieldHandle implements IRuntimeFieldHandle {
    value!: IntPtr;

    constructor(data?: IRuntimeFieldHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.value = _data["value"] ? IntPtr.fromJS(_data["value"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): RuntimeFieldHandle | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<RuntimeFieldHandle>(data, _mappings, RuntimeFieldHandle);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value ? this.value.toJSON() : <any>null;
        return data;
    }
}

export interface IRuntimeFieldHandle {
    value: IntPtr;
}

export abstract class PropertyInfo extends MemberInfo implements IPropertyInfo {
    memberType!: MemberTypes;
    propertyType!: string;
    attributes!: PropertyAttributes;
    isSpecialName!: boolean;
    canRead!: boolean;
    canWrite!: boolean;
    getMethod!: MethodInfo | null;
    setMethod!: MethodInfo | null;

    constructor(data?: IPropertyInfo) {
        super(data);
    }

    init(_data?: any, _mappings?: any) {
        super.init(_data);
        if (_data) {
            this.memberType = _data["memberType"] !== undefined ? _data["memberType"] : <any>null;
            this.propertyType = _data["propertyType"] !== undefined ? _data["propertyType"] : <any>null;
            this.attributes = _data["attributes"] !== undefined ? _data["attributes"] : <any>null;
            this.isSpecialName = _data["isSpecialName"] !== undefined ? _data["isSpecialName"] : <any>null;
            this.canRead = _data["canRead"] !== undefined ? _data["canRead"] : <any>null;
            this.canWrite = _data["canWrite"] !== undefined ? _data["canWrite"] : <any>null;
            this.getMethod = _data["getMethod"] ? MethodInfo.fromJS(_data["getMethod"], _mappings) : <any>null;
            this.setMethod = _data["setMethod"] ? MethodInfo.fromJS(_data["setMethod"], _mappings) : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): PropertyInfo | null {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PropertyInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberType"] = this.memberType !== undefined ? this.memberType : <any>null;
        data["propertyType"] = this.propertyType !== undefined ? this.propertyType : <any>null;
        data["attributes"] = this.attributes !== undefined ? this.attributes : <any>null;
        data["isSpecialName"] = this.isSpecialName !== undefined ? this.isSpecialName : <any>null;
        data["canRead"] = this.canRead !== undefined ? this.canRead : <any>null;
        data["canWrite"] = this.canWrite !== undefined ? this.canWrite : <any>null;
        data["getMethod"] = this.getMethod ? this.getMethod.toJSON() : <any>null;
        data["setMethod"] = this.setMethod ? this.setMethod.toJSON() : <any>null;
        super.toJSON(data);
        return data;
    }
}

export interface IPropertyInfo extends IMemberInfo {
    memberType: MemberTypes;
    propertyType: string;
    attributes: PropertyAttributes;
    isSpecialName: boolean;
    canRead: boolean;
    canWrite: boolean;
    getMethod: MethodInfo | null;
    setMethod: MethodInfo | null;
}

export enum PropertyAttributes {
    None = 0,
    SpecialName = 512,
    RTSpecialName = 1024,
    HasDefault = 4096,
    Reserved2 = 8192,
    Reserved3 = 16384,
    Reserved4 = 32768,
    ReservedMask = 62464,
}

export enum SecurityRuleSet {
    None = 0,
    Level1 = 1,
    Level2 = 2,
}

export class ModuleHandle implements IModuleHandle {
    mdStreamVersion!: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.mdStreamVersion = _data["mdStreamVersion"] !== undefined ? _data["mdStreamVersion"] : <any>null;
        }
    }

    static fromJS(data: any, _mappings?: any): ModuleHandle | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ModuleHandle>(data, _mappings, ModuleHandle);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mdStreamVersion"] = this.mdStreamVersion !== undefined ? this.mdStreamVersion : <any>null;
        return data;
    }
}

export interface IModuleHandle {
    mdStreamVersion: number;
}

export enum EventMessageType {
    Default = 0,
    Info = 1,
    Error = 2,
    Success = 3,
    Warning = 4,
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;
        
        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }
        
        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
  if (!mappings)
    mappings = [];
  if (!data)
    return null;

  const mappingIndexName = "__mappingIndex";
  if (data[mappingIndexName])
    return <T>mappings[data[mappingIndexName]].target;

  data[mappingIndexName] = mappings.length;

  let result: any = new type();
  mappings.push({ source: data, target: result });
  result.init(data, mappings);
  return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}